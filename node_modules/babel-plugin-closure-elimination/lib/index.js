'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = build;

require('babel-polyfill');

/**
 * # Closure Eliminator
 */

var $boundArrowFunction = Symbol('boundArrowFunction');
var $usedEval = Symbol('usedEval');

function _ref2(_ref) {
  var node = _ref.node;
  return node._generated || node._compact;
}

function _ref3(path) {
  return path.isFunction();
}

function _ref4(path) {
  return path.type !== 'ArrowFunctionExpression';
}

function _ref5(parentArrow) {
  parentArrow.node[$boundArrowFunction] = true;
}

function _enter(path) {
  var parentFunctions = path.getAncestry().filter(_ref3),
      nearestNoArrowFunction = parentFunctions.findIndex(_ref4);
  parentFunctions.slice(0, nearestNoArrowFunction).forEach(_ref5);
}

function _ref6(path) {
  return path.isFunction();
}

function _ref7(parentArrow) {
  parentArrow.node[$usedEval] = true;
}

function _enter2(path) {
  if (path.node.name === 'eval' && path.parentPath.type === 'CallExpression') {
    path.getAncestry().filter(_ref6).forEach(_ref7);
  }
}

function _ref9(_ref8) {
  var path = _ref8.path;
  return !path.isProgram() || path.node.sourceType === 'module';
}

function getAllParentScopes(scope) {
  var scopes = [];
  while (scope = scope.parent) {
    scopes.push(scope);
  }
  return scopes;
}

function getAttachmentPosition(bestParent, prevPath) {
  var prevParents = prevPath.getAncestry(),
      bestParentIdx = prevParents.indexOf(bestParent);
  if (-1 === bestParentIdx) {
    throw new Error('Possible parent not really in ancestry');
  }
  return prevParents.slice(1, bestParentIdx).reverse().find(function (path) {
    return (path.parentPath.isBlockStatement() || path.parentPath.isProgram()) && path.parentPath.scope !== prevPath.parentPath.scope;
  });
}

function _logAllProgram(path, label) {
  var rootNode = path.getAncestry().pop().node;
  console.error(label);
  console.error(require('babel-generator').default(rootNode).code);
  console.error('\n=======================================================\n');
}
function build(babel) {
  var t = babel.types;


  return {
    visitor: {
      Function: {
        exit: function exit(path) {
          var node = path.node;

          path.scope.crawl(); // sibling plugins may not update scope of auto-generated functions
          if (path.node._hoisted) {
            return;
          }
          if (path.isClassMethod() || path.isObjectMethod() || node[$boundArrowFunction] || node[$usedEval]) {
            return;
          }
          if (path.findParent(_ref2)) {
            path.skip();
            return;
          }
          var bestParentScope = getHighestCompatibleHoistedScope(path);
          if (bestParentScope) {
            var attachPath = getAttachmentPosition(bestParentScope.path, path);
            if (attachPath) {
              // _logAllProgram(path, 'before');// debug
              moveToNewPosition(path, attachPath);
              // _logAllProgram(path, 'after');// debug
            }
          }
        }
      },
      ThisExpression: {
        enter: _enter
      },
      Identifier: {
        enter: _enter2
      }
    }
  };

  function getHighestCompatibleHoistedScope(path) {
    var parentScopes = getAllParentScopes(path.scope),
        parentBindings = path.scope.parent.getAllBindings();
    for (var id in parentBindings) {
      var parentBinding = parentBindings[id],
          idx = parentScopes.indexOf(parentBinding.scope);
      if (idx === -1) {
        continue;
      }
      var hasUsageOfBinding = [].concat(parentBinding.referencePaths).concat(parentBinding.constantViolations).some(hasInPath);
      if (hasUsageOfBinding) {
        parentScopes.splice(idx + 1, Infinity);
      }
    }
    return parentScopes.filter(_ref9).filter(function (scope) {
      return scope !== path.scope.parent;
    }).pop();
    function hasInPath(subPath) {
      while (subPath = subPath.parentPath) {
        if (subPath === path) {
          return true;
        }
      }
    }
  }function moveToNewPosition(path, attachPath) {
    var node = path.node,
        scope = path.scope,
        newScope = attachPath.parentPath.scope;

    if (node.type === 'FunctionDeclaration') {
      if (newScope.bindings[node.id.name]) {
        var uid = newScope.generateUidIdentifierBasedOnNode(node.id);
        scope.rename(node.id.name, uid.name);
      }
      scope.moveBindingTo(node.id.name, newScope);
      node._hoisted = true;
      attachPath.insertBefore([node]);
      path.remove();
    } else {
      var _uid = path.parentPath.scope.generateUidIdentifierBasedOnNode(node.id),
          replacement = t.functionDeclaration(_uid, node.params, normalizeFunctionBody(node.body));
      if (node.id && node.id.name) {
        // fix for auto-generated named expression function, when node.id duplicated in AST in outer VariableDeclaration
        node.id = t.cloneDeep(node.id);
        scope.crawl();

        scope.rename(node.id.name, _uid.name);
        scope.moveBindingTo(node.id.name, newScope);
      }
      replacement.loc = node.loc;
      replacement.generator = node.generator;
      replacement.async = node.async;
      replacement._hoisted = true;
      var declarePath = attachPath.insertBefore([replacement])[0];
      path.replaceWith(t.identifier(_uid.name));
      if (!newScope.bindings[_uid.name]) {
        newScope.registerDeclaration(declarePath);
      }
      newScope.bindings[_uid.name].reference(path);
    }
  }

  /**
   * Normalize a function body so that it is always a BlockStatement.
   */
  function normalizeFunctionBody(node) {
    if (node.type !== 'BlockStatement') {
      return t.blockStatement([t.returnStatement(node)]);
    } else {
      return node;
    }
  }
}